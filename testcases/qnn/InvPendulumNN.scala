
import daisy.lang._
import Vector._

object InvPendulumNN {

  def nn1(x: Vector): Vector = {
    // the last input (angular velocity) is unconstrained. I assumed it as [0, pi
    require(lowerBounds(x, List(-0.7, -1.0, -0.5236, 0.0)) &&
      upperBounds(x, List(0.7, 1.0, 0.5236, 3.14)))

    val weights1 = Matrix(List(
      List(-0.87796504, 0.49901101, 0.71454037, 0.60627043),
      List(-0.12559077, -0.71710082, 0.25209344, 0.06111571),
      List(-0.34278285, -0.06739243, -0.6965151, -1.0038189),
      List(0.12920291, -0.69232796, 0.14556374, 0.41597126),
      List(1.53150904, 2.29478818, 3.39869284, 0.28470497),
      List(-0.7424501, 0.61288627, 0.806291, 0.31396899),
      List(-0.08479985, -1.35184861, -6.23189326, -1.85929063),
      List(-1.04077445, 0.36186145, -0.11679802, -0.3906688),
      List(0.48112712, -0.46653835, -1.86325403, -0.79252175),
      List(0.63784228, -0.53025377, -1.09627429, -0.55679737)))

    val weights2 = Matrix(List(
      List(7.87135430e-01, -6.17527200e-01, -7.71196974e-01,
          8.76145832e-01, 4.29984875e+00, -7.78517245e-01,
          -6.50494973e+00, 3.30555729e-12, -1.83581283e+00, -8.12065464e-01)))

    val bias1 = Vector(List(-0.69577008, -0.59025015, 0.85458828,
                       -0.96125374, 2.09416249, -0.9418259, 1.22624701,
                       -0.25044766, 0.5365559, 0.40367892))
    val bias2 = Vector(List(0.94397898))

    val layer1 = relu(weights1 * x + bias1)
    val layer2 = linear(weights2 * layer1 + bias2)
    layer2

  } ensuring(res => res +/- 1e-3)
  // ensuring(res => res +/- 1e-5)
}
